{"version":3,"file":"8313.436936d.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@codemirror/search/dist/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/crelt/index.js"],"sourcesContent":["import { showDialog, EditorView, Decoration, ViewPlugin, showPanel, runScopeHandlers, getPanel } from '@codemirror/view';\nimport { codePointAt, fromCodePoint, codePointSize, EditorSelection, Facet, combineConfig, CharCategory, StateEffect, StateField, RangeSetBuilder, Prec, EditorState, findClusterBreak } from '@codemirror/state';\nimport elt from 'crelt';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize, test) {\n        this.test = test;\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += codePointSize(next);\n            let norm = this.normalize(str);\n            if (norm.length)\n                for (let i = 0, pos = start;; i++) {\n                    let code = norm.charCodeAt(i);\n                    let match = this.match(code, pos, this.bufferPos + this.bufferStart);\n                    if (i == norm.length - 1) {\n                        if (match) {\n                            this.value = match;\n                            return this;\n                        }\n                        break;\n                    }\n                    if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                        pos++;\n                }\n        }\n    }\n    match(code, pos, end) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: end };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: end };\n            else\n                this.matches.push(1, pos);\n        }\n        if (match && this.test && !this.test(match.from, match.to, this.buffer, this.bufferStart))\n            match = null;\n        return match;\n    }\n}\nif (typeof Symbol != \"undefined\")\n    SearchCursor.prototype[Symbol.iterator] = function () { return this; };\n\nconst empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\nclass RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.text = text;\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */\n        this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = toCharEnd(text, from);\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                if (from == this.curLineStart + this.curLine.length)\n                    this.nextLine();\n                if ((from < to || from > this.value.to) && (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = toCharEnd(text, from);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.test = options === null || options === void 0 ? void 0 : options.test;\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Chunk.Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                // If a match goes almost to the end of a noncomplete chunk, try\n                // again, since it'll likely be able to match more\n                if ((this.flat.to >= this.to || match.index + match[0].length <= this.flat.text.length - 10) &&\n                    (!this.test || this.test(from, to, match))) {\n                    this.value = { from, to, match };\n                    this.matchPos = toCharEnd(this.text, to + (from == to ? 1 : 0));\n                    return this;\n                }\n            }\n            if (this.flat.to == this.to) {\n                this.done = true;\n                return this;\n            }\n            // Grow the flattened doc\n            this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n        }\n    }\n}\nif (typeof Symbol != \"undefined\") {\n    RegExpCursor.prototype[Symbol.iterator] = MultilineRegExpCursor.prototype[Symbol.iterator] =\n        function () { return this; };\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction toCharEnd(text, pos) {\n    if (pos >= text.length)\n        return pos;\n    let line = text.lineAt(pos), next;\n    while (pos < line.to && (next = line.text.charCodeAt(pos - line.from)) >= 0xDC00 && next < 0xE000)\n        pos++;\n    return pos;\n}\n\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n*/\nconst gotoLine = view => {\n    let { state } = view;\n    let line = String(state.doc.lineAt(view.state.selection.main.head).number);\n    let { close, result } = showDialog(view, {\n        label: state.phrase(\"Go to line\"),\n        input: { type: \"text\", name: \"line\", value: line },\n        focus: true,\n        submitLabel: state.phrase(\"go\"),\n    });\n    result.then(form => {\n        let match = form && /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(form.elements[\"line\"].value);\n        if (!match) {\n            view.dispatch({ effects: close });\n            return;\n        }\n        let startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        let selection = EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length)));\n        view.dispatch({\n            effects: [close, EditorView.scrollIntoView(selection.from, { y: 'center' })],\n            selection,\n        });\n    });\n    return true;\n};\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100,\n    wholeWords: false\n};\nconst highlightConfig = /*@__PURE__*/Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\n// Whether the characters directly outside the given positions are non-word characters\nfunction insideWordBoundaries(check, state, from, to) {\n    return (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n        (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word);\n}\n// Whether the characters directly at the given positions are word characters\nfunction insideWord(check, state, from, to) {\n    return check(state.sliceDoc(from, from + 1)) == CharCategory.Word\n        && check(state.sliceDoc(to - 1, to)) == CharCategory.Word;\n}\nconst matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            if (conf.wholeWords) {\n                query = state.sliceDoc(range.from, range.to); // TODO: allow and include leading/trailing space?\n                check = state.charCategorizer(range.head);\n                if (!(insideWordBoundaries(check, state, range.from, range.to) &&\n                    insideWord(check, state, range.from, range.to)))\n                    return Decoration.none;\n            }\n            else {\n                query = state.sliceDoc(range.from, range.to);\n                if (!query)\n                    return Decoration.none;\n            }\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.next().done) {\n                let { from, to } = cursor.value;\n                if (!check || insideWordBoundaries(check, state, from, to)) {\n                    if (range.empty && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch }) => {\n    let { selection } = state;\n    let newSel = EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection))\n        return false;\n    dispatch(state.update({ selection: newSel }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { main, ranges } = state.selection;\n    let word = state.wordAt(main.head), fullWord = word && word.from == main.from && word.to == main.to;\n    for (let cycled = false, cursor = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to);;) {\n        cursor.next();\n        if (cursor.done) {\n            if (cycled)\n                return null;\n            cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n            cycled = true;\n        }\n        else {\n            if (cycled && ranges.some(r => r.from == cursor.value.from))\n                continue;\n            if (fullWord) {\n                let word = state.wordAt(cursor.value.from);\n                if (!word || word.from != cursor.value.from || word.to != cursor.value.to)\n                    continue;\n            }\n            return cursor.value;\n        }\n    }\n}\n/**\nSelect next occurrence of the current selection. Expand selection\nto the surrounding word when the selection is empty.\n*/\nconst selectNextOccurrence = ({ state, dispatch }) => {\n    let { ranges } = state.selection;\n    if (ranges.some(sel => sel.from === sel.to))\n        return selectWord({ state, dispatch });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))\n        return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range)\n        return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(EditorSelection.range(range.from, range.to), false),\n        effects: EditorView.scrollIntoView(range.to)\n    }));\n    return true;\n};\n\nconst searchConfigFacet = /*@__PURE__*/Facet.define({\n    combine(configs) {\n        return combineConfig(configs, {\n            top: false,\n            caseSensitive: false,\n            literal: false,\n            regexp: false,\n            wholeWord: false,\n            createPanel: view => new SearchPanel(view),\n            scrollToMatch: range => EditorView.scrollIntoView(range)\n        });\n    }\n});\n/**\nAdd search state to the editor configuration, and optionally\nconfigure the search extension.\n([`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) will automatically\nenable this if it isn't already on).\n*/\nfunction search(config) {\n    return config ? [searchConfigFacet.of(config), searchExtensions] : searchExtensions;\n}\n/**\nA search query. Part of the editor's search state.\n*/\nclass SearchQuery {\n    /**\n    Create a query object.\n    */\n    constructor(config) {\n        this.search = config.search;\n        this.caseSensitive = !!config.caseSensitive;\n        this.literal = !!config.literal;\n        this.regexp = !!config.regexp;\n        this.replace = config.replace || \"\";\n        this.valid = !!this.search && (!this.regexp || validRegExp(this.search));\n        this.unquoted = this.unquote(this.search);\n        this.wholeWord = !!config.wholeWord;\n        this.test = config.test;\n    }\n    /**\n    @internal\n    */\n    unquote(text) {\n        return this.literal ? text :\n            text.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    /**\n    Compare this query to another query.\n    */\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseSensitive == other.caseSensitive && this.regexp == other.regexp &&\n            this.wholeWord == other.wholeWord && this.test == other.test;\n    }\n    /**\n    @internal\n    */\n    create() {\n        return this.regexp ? new RegExpQuery(this) : new StringQuery(this);\n    }\n    /**\n    Get a search cursor for this query, searching through the given\n    range in the given state.\n    */\n    getCursor(state, from = 0, to) {\n        let st = state.doc ? state : EditorState.create({ doc: state });\n        if (to == null)\n            to = st.doc.length;\n        return this.regexp ? regexpCursor(this, st, from, to) : stringCursor(this, st, from, to);\n    }\n}\nclass QueryType {\n    constructor(spec) {\n        this.spec = spec;\n    }\n}\nfunction wrapStringTest(test, state, inner) {\n    return (from, to, buffer, bufferPos) => {\n        if (inner && !inner(from, to, buffer, bufferPos))\n            return false;\n        let match = from >= bufferPos && to <= bufferPos + buffer.length\n            ? buffer.slice(from - bufferPos, to - bufferPos)\n            : state.doc.sliceString(from, to);\n        return test(match, state, from, to);\n    };\n}\nfunction stringCursor(spec, state, from, to) {\n    let test;\n    if (spec.wholeWord)\n        test = stringWordTest(state.doc, state.charCategorizer(state.selection.main.head));\n    if (spec.test)\n        test = wrapStringTest(spec.test, state, test);\n    return new SearchCursor(state.doc, spec.unquoted, from, to, spec.caseSensitive ? undefined : x => x.toLowerCase(), test);\n}\nfunction stringWordTest(doc, categorizer) {\n    return (from, to, buf, bufPos) => {\n        if (bufPos > from || bufPos + buf.length < to) {\n            bufPos = Math.max(0, from - 2);\n            buf = doc.sliceString(bufPos, Math.min(doc.length, to + 2));\n        }\n        return (categorizer(charBefore(buf, from - bufPos)) != CharCategory.Word ||\n            categorizer(charAfter(buf, from - bufPos)) != CharCategory.Word) &&\n            (categorizer(charAfter(buf, to - bufPos)) != CharCategory.Word ||\n                categorizer(charBefore(buf, to - bufPos)) != CharCategory.Word);\n    };\n}\nclass StringQuery extends QueryType {\n    constructor(spec) {\n        super(spec);\n    }\n    nextMatch(state, curFrom, curTo) {\n        let cursor = stringCursor(this.spec, state, curTo, state.doc.length).nextOverlapping();\n        if (cursor.done) {\n            let end = Math.min(state.doc.length, curFrom + this.spec.unquoted.length);\n            cursor = stringCursor(this.spec, state, 0, end).nextOverlapping();\n        }\n        return cursor.done || cursor.value.from == curFrom && cursor.value.to == curTo ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing an inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(state, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* FindPrev.ChunkSize */ - this.spec.unquoted.length);\n            let cursor = stringCursor(this.spec, state, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* FindPrev.ChunkSize */;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        let found = this.prevMatchInRange(state, 0, curFrom);\n        if (!found)\n            found = this.prevMatchInRange(state, Math.max(0, curTo - this.spec.unquoted.length), state.doc.length);\n        return found && (found.from != curFrom || found.to != curTo) ? found : null;\n    }\n    getReplacement(_result) { return this.spec.unquote(this.spec.replace); }\n    matchAll(state, limit) {\n        let cursor = stringCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = stringCursor(this.spec, state, Math.max(0, from - this.spec.unquoted.length), Math.min(to + this.spec.unquoted.length, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nfunction wrapRegexpTest(test, state, inner) {\n    return (from, to, match) => {\n        return (!inner || inner(from, to, match)) && test(match[0], state, from, to);\n    };\n}\nfunction regexpCursor(spec, state, from, to) {\n    let test;\n    if (spec.wholeWord)\n        test = regexpWordTest(state.charCategorizer(state.selection.main.head));\n    if (spec.test)\n        test = wrapRegexpTest(spec.test, state, test);\n    return new RegExpCursor(state.doc, spec.search, { ignoreCase: !spec.caseSensitive, test }, from, to);\n}\nfunction charBefore(str, index) {\n    return str.slice(findClusterBreak(str, index, false), index);\n}\nfunction charAfter(str, index) {\n    return str.slice(index, findClusterBreak(str, index));\n}\nfunction regexpWordTest(categorizer) {\n    return (_from, _to, match) => !match[0].length ||\n        (categorizer(charBefore(match.input, match.index)) != CharCategory.Word ||\n            categorizer(charAfter(match.input, match.index)) != CharCategory.Word) &&\n            (categorizer(charAfter(match.input, match.index + match[0].length)) != CharCategory.Word ||\n                categorizer(charBefore(match.input, match.index + match[0].length)) != CharCategory.Word);\n}\nclass RegExpQuery extends QueryType {\n    nextMatch(state, curFrom, curTo) {\n        let cursor = regexpCursor(this.spec, state, curTo, state.doc.length).next();\n        if (cursor.done)\n            cursor = regexpCursor(this.spec, state, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(state, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* FindPrev.ChunkSize */);\n            let cursor = regexpCursor(this.spec, state, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(state, curFrom, curTo) {\n        return this.prevMatchInRange(state, 0, curFrom) ||\n            this.prevMatchInRange(state, curTo, state.doc.length);\n    }\n    getReplacement(result) {\n        return this.spec.unquote(this.spec.replace).replace(/\\$([$&]|\\d+)/g, (m, i) => {\n            if (i == \"&\")\n                return result.match[0];\n            if (i == \"$\")\n                return \"$\";\n            for (let l = i.length; l > 0; l--) {\n                let n = +i.slice(0, l);\n                if (n > 0 && n < result.match.length)\n                    return result.match[n] + i.slice(l);\n            }\n            return m;\n        });\n    }\n    matchAll(state, limit) {\n        let cursor = regexpCursor(this.spec, state, 0, state.doc.length), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(state, from, to, add) {\n        let cursor = regexpCursor(this.spec, state, Math.max(0, from - 250 /* RegExp.HighlightMargin */), Math.min(to + 250 /* RegExp.HighlightMargin */, state.doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\n/**\nA state effect that updates the current search query. Note that\nthis only has an effect if the search state has been initialized\n(by including [`search`](https://codemirror.net/6/docs/ref/#search.search) in your configuration or\nby running [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel) at least\nonce).\n*/\nconst setSearchQuery = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst searchState = /*@__PURE__*/StateField.define({\n    create(state) {\n        return new SearchState(defaultQuery(state).create(), null);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setSearchQuery))\n                value = new SearchState(effect.value.create(), value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val.panel)\n});\n/**\nGet the current search query from an editor state.\n*/\nfunction getSearchQuery(state) {\n    let curState = state.field(searchState, false);\n    return curState ? curState.query.spec : defaultQuery(state);\n}\n/**\nQuery whether the search panel is open in the given editor state.\n*/\nfunction searchPanelOpen(state) {\n    var _a;\n    return ((_a = state.field(searchState, false)) === null || _a === void 0 ? void 0 : _a.panel) != null;\n}\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet || update.viewportChanged)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.spec.valid)\n            return Decoration.none;\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* RegExp.HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.spec.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { to } = view.state.selection.main;\n    let next = query.nextMatch(view.state, to, to);\n    if (!next)\n        return false;\n    let selection = EditorSelection.single(next.from, next.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, next), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from } = state.selection.main;\n    let prev = query.prevMatch(state, from, from);\n    if (!prev)\n        return false;\n    let selection = EditorSelection.single(prev.from, prev.to);\n    let config = view.state.facet(searchConfigFacet);\n    view.dispatch({\n        selection,\n        effects: [announceMatch(view, prev), config.scrollToMatch(selection.main, view)],\n        userEvent: \"select.search\"\n    });\n    selectSearchInput(view);\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to))),\n        userEvent: \"select.search.matches\"\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({\n        selection: EditorSelection.create(ranges, main),\n        userEvent: \"select.search.matches\"\n    }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    if (state.readOnly)\n        return false;\n    let match = query.nextMatch(state, from, from);\n    if (!match)\n        return false;\n    let next = match;\n    let changes = [], selection, replacement;\n    let effects = [];\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state, next.from, next.to);\n        effects.push(EditorView.announce.of(state.phrase(\"replaced match on line $\", state.doc.lineAt(from).number) + \".\"));\n    }\n    let changeSet = view.state.changes(changes);\n    if (next) {\n        selection = EditorSelection.single(next.from, next.to).map(changeSet);\n        effects.push(announceMatch(view, next));\n        effects.push(state.facet(searchConfigFacet).scrollToMatch(selection.main, view));\n    }\n    view.dispatch({\n        changes: changeSet,\n        selection,\n        effects,\n        userEvent: \"input.replace\"\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {\n    if (view.state.readOnly)\n        return false;\n    let changes = query.matchAll(view.state, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    let announceText = view.state.phrase(\"replaced $ matches\", changes.length) + \".\";\n    view.dispatch({\n        changes,\n        effects: EditorView.announce.of(announceText),\n        userEvent: \"input.replace.all\"\n    });\n    return true;\n});\nfunction createSearchPanel(view) {\n    return view.state.facet(searchConfigFacet).createPanel(view);\n}\nfunction defaultQuery(state, fallback) {\n    var _a, _b, _c, _d, _e;\n    let sel = state.selection.main;\n    let selText = sel.empty || sel.to > sel.from + 100 ? \"\" : state.sliceDoc(sel.from, sel.to);\n    if (fallback && !selText)\n        return fallback;\n    let config = state.facet(searchConfigFacet);\n    return new SearchQuery({\n        search: ((_a = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _a !== void 0 ? _a : config.literal) ? selText : selText.replace(/\\n/g, \"\\\\n\"),\n        caseSensitive: (_b = fallback === null || fallback === void 0 ? void 0 : fallback.caseSensitive) !== null && _b !== void 0 ? _b : config.caseSensitive,\n        literal: (_c = fallback === null || fallback === void 0 ? void 0 : fallback.literal) !== null && _c !== void 0 ? _c : config.literal,\n        regexp: (_d = fallback === null || fallback === void 0 ? void 0 : fallback.regexp) !== null && _d !== void 0 ? _d : config.regexp,\n        wholeWord: (_e = fallback === null || fallback === void 0 ? void 0 : fallback.wholeWord) !== null && _e !== void 0 ? _e : config.wholeWord\n    });\n}\nfunction getSearchInput(view) {\n    let panel = getPanel(view, createSearchPanel);\n    return panel && panel.dom.querySelector(\"[main-field]\");\n}\nfunction selectSearchInput(view) {\n    let input = getSearchInput(view);\n    if (input && input == view.root.activeElement)\n        input.select();\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let searchInput = getSearchInput(view);\n        if (searchInput && searchInput != view.root.activeElement) {\n            let query = defaultQuery(view.state, state.query.spec);\n            if (query.valid)\n                view.dispatch({ effects: setSearchQuery.of(query) });\n            searchInput.focus();\n            searchInput.select();\n        }\n    }\n    else {\n        view.dispatch({ effects: [\n                togglePanel.of(true),\n                state ? setSearchQuery.of(defaultQuery(view.state, state.query.spec)) : StateEffect.appendConfig.of(searchExtensions)\n            ] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Mod-Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\", preventDefault: true },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Mod-Alt-g\", run: gotoLine },\n    { key: \"Mod-d\", run: selectNextOccurrence, preventDefault: true },\n];\nclass SearchPanel {\n    constructor(view) {\n        this.view = view;\n        let query = this.query = view.state.field(searchState).query.spec;\n        this.commit = this.commit.bind(this);\n        this.searchField = elt(\"input\", {\n            value: query.search,\n            placeholder: phrase(view, \"Find\"),\n            \"aria-label\": phrase(view, \"Find\"),\n            class: \"cm-textfield\",\n            name: \"search\",\n            form: \"\",\n            \"main-field\": \"true\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.replaceField = elt(\"input\", {\n            value: query.replace,\n            placeholder: phrase(view, \"Replace\"),\n            \"aria-label\": phrase(view, \"Replace\"),\n            class: \"cm-textfield\",\n            name: \"replace\",\n            form: \"\",\n            onchange: this.commit,\n            onkeyup: this.commit\n        });\n        this.caseField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"case\",\n            form: \"\",\n            checked: query.caseSensitive,\n            onchange: this.commit\n        });\n        this.reField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"re\",\n            form: \"\",\n            checked: query.regexp,\n            onchange: this.commit\n        });\n        this.wordField = elt(\"input\", {\n            type: \"checkbox\",\n            name: \"word\",\n            form: \"\",\n            checked: query.wholeWord,\n            onchange: this.commit\n        });\n        function button(name, onclick, content) {\n            return elt(\"button\", { class: \"cm-button\", name, onclick, type: \"button\" }, content);\n        }\n        this.dom = elt(\"div\", { onkeydown: (e) => this.keydown(e), class: \"cm-search\" }, [\n            this.searchField,\n            button(\"next\", () => findNext(view), [phrase(view, \"next\")]),\n            button(\"prev\", () => findPrevious(view), [phrase(view, \"previous\")]),\n            button(\"select\", () => selectMatches(view), [phrase(view, \"all\")]),\n            elt(\"label\", null, [this.caseField, phrase(view, \"match case\")]),\n            elt(\"label\", null, [this.reField, phrase(view, \"regexp\")]),\n            elt(\"label\", null, [this.wordField, phrase(view, \"by word\")]),\n            ...view.state.readOnly ? [] : [\n                elt(\"br\"),\n                this.replaceField,\n                button(\"replace\", () => replaceNext(view), [phrase(view, \"replace\")]),\n                button(\"replaceAll\", () => replaceAll(view), [phrase(view, \"replace all\")])\n            ],\n            elt(\"button\", {\n                name: \"close\",\n                onclick: () => closeSearchPanel(view),\n                \"aria-label\": phrase(view, \"close\"),\n                type: \"button\"\n            }, [\"\"])\n        ]);\n    }\n    commit() {\n        let query = new SearchQuery({\n            search: this.searchField.value,\n            caseSensitive: this.caseField.checked,\n            regexp: this.reField.checked,\n            wholeWord: this.wordField.checked,\n            replace: this.replaceField.value,\n        });\n        if (!query.eq(this.query)) {\n            this.query = query;\n            this.view.dispatch({ effects: setSearchQuery.of(query) });\n        }\n    }\n    keydown(e) {\n        if (runScopeHandlers(this.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == this.searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(this.view);\n        }\n        else if (e.keyCode == 13 && e.target == this.replaceField) {\n            e.preventDefault();\n            replaceNext(this.view);\n        }\n    }\n    update(update) {\n        for (let tr of update.transactions)\n            for (let effect of tr.effects) {\n                if (effect.is(setSearchQuery) && !effect.value.eq(this.query))\n                    this.setQuery(effect.value);\n            }\n    }\n    setQuery(query) {\n        this.query = query;\n        this.searchField.value = query.search;\n        this.replaceField.value = query.replace;\n        this.caseField.checked = query.caseSensitive;\n        this.reField.checked = query.regexp;\n        this.wordField.checked = query.wholeWord;\n    }\n    mount() {\n        this.searchField.select();\n    }\n    get pos() { return 80; }\n    get top() { return this.view.state.facet(searchConfigFacet).top; }\n}\nfunction phrase(view, phrase) { return view.state.phrase(phrase); }\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let line = view.state.doc.lineAt(from), lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(line.from, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != line.from) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${line.number}.`);\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/Prec.low(searchHighlighter),\n    baseTheme\n];\n\nexport { RegExpCursor, SearchCursor, SearchQuery, closeSearchPanel, findNext, findPrevious, getSearchQuery, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, search, searchKeymap, searchPanelOpen, selectMatches, selectNextOccurrence, selectSelectionMatches, setSearchQuery };\n","export default function crelt() {\n  var elt = arguments[0]\n  if (typeof elt == \"string\") elt = document.createElement(elt)\n  var i = 1, next = arguments[1]\n  if (next && typeof next == \"object\" && next.nodeType == null && !Array.isArray(next)) {\n    for (var name in next) if (Object.prototype.hasOwnProperty.call(next, name)) {\n      var value = next[name]\n      if (typeof value == \"string\") elt.setAttribute(name, value)\n      else if (value != null) elt[name] = value\n    }\n    i++\n  }\n  for (; i < arguments.length; i++) add(elt, arguments[i])\n  return elt\n}\n\nfunction add(elt, child) {\n  if (typeof child == \"string\") {\n    elt.appendChild(document.createTextNode(child))\n  } else if (child == null) {\n  } else if (child.nodeType != null) {\n    elt.appendChild(child)\n  } else if (Array.isArray(child)) {\n    for (var i = 0; i < child.length; i++) add(elt, child[i])\n  } else {\n    throw new RangeError(\"Unsupported child node: \" + child)\n  }\n}\n"],"names":["basicNormalize","String","prototype","normalize","x","SearchCursor","constructor","text","query","from","to","length","test","this","value","done","matches","buffer","bufferPos","iter","iterRange","bufferStart","peek","next","codePointAt","pop","nextOverlapping","str","fromCodePoint","start","codePointSize","norm","i","pos","code","charCodeAt","match","end","index","keep","splice","push","Symbol","iterator","empty","exec","baseFlags","unicode","RegExpCursor","options","curLine","MultilineRegExpCursor","re","RegExp","ignoreCase","startLine","lineAt","curLineStart","matchPos","toCharEnd","getLine","skip","lineBreak","slice","nextLine","off","lastIndex","flattened","WeakMap","FlattenedDoc","get","doc","cached","flat","sliceString","set","cachedFrom","chunkEnd","line","gotoLine","view","state","selection","main","head","number","close","result","showDialog","label","phrase","input","type","name","focus","submitLabel","then","form","elements","dispatch","effects","sign","ln","cl","percent","col","pc","lines","Math","round","docLine","max","min","EditorSelection","cursor","EditorView","scrollIntoView","y","defaultHighlightOptions","highlightWordAroundCursor","minSelectionLength","maxMatches","wholeWords","highlightConfig","Facet","define","combine","combineConfig","a","b","highlightSelectionMatches","ext","defaultTheme","matchHighlighter","of","matchDeco","Decoration","mark","class","mainMatchDeco","insideWordBoundaries","check","sliceDoc","CharCategory","Word","ViewPlugin","fromClass","decorations","getDeco","update","selectionSet","docChanged","viewportChanged","conf","facet","sel","ranges","none","range","word","wordAt","charCategorizer","len","insideWord","deco","part","visibleRanges","v","baseTheme","backgroundColor","selectNextOccurrence","some","newSel","create","map","mainIndex","eq","selectWord","searchedText","r","fullWord","cycled","findNextOccurrence","addRange","searchConfigFacet","configs","top","caseSensitive","literal","regexp","wholeWord","createPanel","SearchPanel","scrollToMatch","search","config","searchExtensions","SearchQuery","replace","valid","source","_a","validRegExp","unquoted","unquote","_","ch","other","RegExpQuery","StringQuery","getCursor","st","EditorState","regexpCursor","stringCursor","QueryType","spec","categorizer","buf","bufPos","charBefore","charAfter","inner","wrapStringTest","undefined","toLowerCase","super","nextMatch","curFrom","curTo","prevMatchInRange","prevMatch","found","getReplacement","_result","matchAll","limit","highlight","add","_from","_to","wrapRegexpTest","findClusterBreak","size","m","l","n","setSearchQuery","StateEffect","togglePanel","searchState","StateField","SearchState","defaultQuery","tr","effect","is","panel","createSearchPanel","provide","f","showPanel","val","getSearchQuery","curState","field","searchPanelOpen","matchMark","selectedMatchMark","searchHighlighter","startState","builder","RangeSetBuilder","selected","finish","searchCommand","openSearchPanel","findNext","single","announceMatch","userEvent","selectSearchInput","findPrevious","prev","selectMatches","selectSelectionMatches","cur","replaceNext","readOnly","replacement","changes","toText","insert","announce","changeSet","replaceAll","announceText","fallback","_b","_c","_d","_e","selText","getSearchInput","getPanel","dom","querySelector","root","activeElement","select","searchInput","appendConfig","closeSearchPanel","contains","searchKeymap","key","run","scope","shift","preventDefault","button","onclick","content","commit","bind","searchField","placeholder","onchange","onkeyup","replaceField","caseField","checked","reField","wordField","onkeydown","e","keydown","runScopeHandlers","keyCode","target","shiftKey","transactions","setQuery","mount","AnnounceMargin","Break","lineEnd","padding","position","right","border","font","margin","marginRight","fontSize","whiteSpace","Prec","low","crelt","elt","arguments","document","createElement","nodeType","Array","isArray","Object","hasOwnProperty","call","setAttribute","child","appendChild","createTextNode","RangeError"],"sourceRoot":""}